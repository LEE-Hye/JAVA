------------------------------이클립스 설치-------------------------------------
1. JDK 1.8 검색(Java Development Kit) -> 첫번째 것 접속(오라클 홈페이지) -> Java SE Development Kit 8u202 -> window x64 다운로드
2. eclipse 검색(Tool) -> 첫번째 것 접속(이클립스 홈페이지) -> Download Package -> 21년 9월 버전 -> Eclipse IDE for Enterprise Java and Web Developers 다운로드
--------------------------------------------------------------------------
JDK(Java Development Kit)  
  - JRE(Java Runtime Environment)
  - JVM(Java virtual Machine) 가상 머신
IDE(Intergrated Development Environment) 작업 공간
  ex) Eclipse, Visual Studio, Android Studio 등
--------------------------------------------------------------------------
1) 환경구축
  - JDK
  - Eclipse
2) 입출력
  - 출력 : System.out.println(출력);
    -> 숫자 + 숫자 = 숫자
    -> 숫자 + 문자 = 문자
  - 입력 : ① 도구 생성(SCanner sc = new Scanner(System.in))
          ② sc.nextInt(), sc.next(); -> 도구 사용
3) 변수 
  : 값을 저장(기억)하는 메모리 공간
  - 숫자 
    -> 정수 - int ex) int a = 10; (정수 타입인 a인 변수에 10을 대입한다)
    -> 실수 - double
  - 문자
    -> char, string(char[])
  - 논리 
    -> ★ boolean(true, false) 
    - 대소문자 구분(아스키코드)
      -> A - 65, B - 66 / a - 97, b - 98
  -> 생성 : 자료형을 붙인다
  -> 사용 : 생성을 하지 않은 변수는 사용할 수 없다.
4) 연산자
  - 결과값이 숫자(산술) : +, -, *, %(나머지), /(몫)
  - 결과값이 논리(논리, 비교) : &&(논리곱), ||(논리합) / ==(같냐?), !=, >=, <=
  - 결과값이 없음(증감, 대입, 삼항) : a++, ++a / a = b(b를 a에 대입) / 조건 ? choice1(출력문 말고 값을 적어줌) : choice2(true면 1, false면 2)
5) 조건문
  - 비교(논리) 연산의 결과에 따라서 명령어를 제어하기 위해 사용(제어 = 조건문 + 반복문)
  if(조건1){ -> 만약에 조건1이 참이면 실행1을 수행!
    실행1;
  }else if(조건2){ -> 그렇지 않고 만약에 조건2라면 실행2를 수행
    실행2   
  }else{  -> 위 조건이 참이 아니라면 실행2를 수행 
    실행3;
  };
  - if문 안에 if문 적는 건 중첩if문

6. 반복문
  - 특정 조건을 만족하는 동안 해당 명령(반복할 명령(범위))을 수행 
    ex) 30만원 수익이 날 때까지 반복 => 횟수 모를 때 while문 적합
    ex) 하루에 10번 주문 받는다 => 횟수 알 때 for문(시작, 끝, 단계를 알 때) 적합
      ex) 1부터 10까지 1씩 증가 / 10부터 100까지 5씩 증가 => 이런 경우는 for문을 써야 함
  for(초기화 구문; 검사조건; 반복후 작업){
    실행할 명령
  };
  -> 초기화 구문 -> 검사조건 -> 실행할 명령 -> 반복후 작업 -> 검사조건 -> 계속 반복
  --------------------------------------------------------------------------------
7. 배열
  : 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것
  - 순서가 없는 데이터에 순서를 부여해주는 것(인덱스를 넣어주는 것)
  1. 반복 사용 가능
  2. 검색 가능
  3. 정렬 가능
생성하면 주소가 생김
[주소=레퍼런스변수] = [메모리=방크기];
데이터타입 [] 변수명 = new 데이터타입 [크기];

8. 메소드(Method)
- 설계는 항상 추상적으로(두루뭉술하게 유연하게) 어떤 데이터가 들어가도 적용할 수 있도록
- 모든 프로그래밍은 끈끈하지않게, 의존적이지 않게 독립적으로 짠다.
- 메소드 : 특정 명령을 모듈화 하는 기법
      ex) 주스를 만든다 라는걸 메소드라 함
- 매개변수(파라미터) : 메소드가 명령을 처리하기 위해 전달받아야하는 데이터 
      ex) 과일 주스 만들기 위한 과일이랑 컵 같은 걸 매개변수라 함
- 리턴값 : 메소드가 해당명령을 수행한 후 반환하는 값(변수, 배열 등)
      ex) 완성된 과일 주스를 받는다
      -> 호출한 곳으로 돌려줌

[메소드 장점]
1. 코드의 중복을 최소화 할 수 있음
2. 모듈화로 인해 가독성이 좋아지고 기능변경 시 빠른 수정이 가능
  -> 유지보수에 용이함
  
[구조 익히기]
public static int add(int a, int b){
  return a+b;
}

- 접근 제한자
    ex) public protected default private
    => public default는 . 찍고 바로 접근 가능
    => private은 get 사용해서 접근
- 메모리 할당 위치
    ex) static
- 리턴 타입
    ex) int(리턴 할거야), void(리턴 안 할거야)
- 메소드 이름
    ex) add
    => 특문은 '_'와 '$'만 가능
- 매개변수
    ex) int a, int b
    => 개수 제한 없음, 필요 없으면 생략 가능
    => 여러개 넣어줄 때 자료형 하나하나 붙여줘야 함
    => 호출할 때 짝 맞춰서 값 
- 리턴 키워드
    ex) return
    => 메소드는 리턴을 만나면 그 즉시 호출한 곳으로 돌아감
- 리턴 값
    ex) a+b
    => 리턴값의 타입은 리턴 타입과 맞춰줘야 한다.


9. 객체지향 프로그래밍
  - 객체 지향은 파트를 나눠서 만든건데 중요한 건 호환을 위한 규격이 있어야 한다 
    => 추상클래스 인터페이스
  - 객체들의 모임으로 프로그래밍을 하는 것이고 각 객체는 메시지를 주고 받고 데이터를 처리
  - 의존적이지 않고 추상적으로 설계
    ex) 컴퓨터에서 마우스나 키보드 등이 없다고 안 돌아가는 건 아님. 
  [특징]
  1-1. 추상화(abstract)
    -> 설계는 추상적으로 해야한다.
    -> 공통된 속성과 행위를 추출, 추상적인 속성과 기능을 중시
    ex) 사람에 대해 나이가 몇살인지 확실하게 말해주는게 아닌 사람의 특징에는 나이 키 몸무게 등이 있다는 것 처럼 추상적으로 설명
  1-2. 다형성(polymorphism)
    -> 추상적으로 설계를 했기 때문에 다양하게 나타낼 수 있다.
    -> 다양한 형태로 나타날 수 있는 능력, 같은 클래스로 다양한 형태의 객체를 생성
      클래스 : 설계도 (한번만 만들면 됨)
      객체 : 실제 만들어진 메모리, 구체화 시킨 것(여러개 찍어냄)
  2. 상속(i) <-> 추상화
    -> 추상적인 걸 한단계 좀 더 구체적으로 설계
    -> 위 부분이 좀 더 추상화 됐다는 개념이라 화살표를 위로 그림(올라가면 올라갈수록 추상적이다) => 내려오는 과정을 상속이라 함
  3. 캡슐화(encapsulation)
    -> 한번 결정 됐으면 고치면 안되고 고치려면 고치는 기능을 사용해야함(get메소드 사용) => private(접근제한자)으로 감쌈
    -> 실제 구현 내용을 외부로부터 감추는 기법(정보은닉)
    -> 타인의 외부 조작 


------------------------------------------------------------------------------------------------
10. 상속 (2022-09-07 상속 업캐스팅 활용)
  ① 상위 클래스의 기능을 그대로 물려 받아 하위 클래스 기능으로도 사용할 수 있는 것이다.
  ② 상속 횟수에는 제한이 없지만 바로 위 상위 클래스가 한개여야만 한다.(다중 상속 지원 안함) 
  ③ 하위 클래스는 상위 클래스 계열이라고 부를 수 있다.(업캐스팅)
    -> 하위 클래스 타입의 객체가 상위 클래스 타입으로 형변환이 가능하다.
  - 상위 클래스 = 부모 클래스 = super 클래스
  - 하위 클래스 = 자식 클래서 = sub 클래스
  - 모든 클래스의 최상위 클래스는 Object 클래스이다.
  
  [업캐스팅]
    - 게임기 / cd - 마리오 cd
                - 쏘닉 cd
      -> 이렇게 나눠져 있으면 추상화 된 CD라는 규격이 있으면 게임기를 사용할 수 있다.
      -> 의존성을 제거했다.
    - 업캐스팅을 쓰면 얼마나 좋은가?
      - 중복 정의 사용하는 이유가 사용하는 사람이 쓰기 편하게
        -> 오버로딩
  - 오버라이딩이란?
    : 상속 관계에서 상위클래스에 설계된 메소드를 하위클래스에서 재정의
      => 업캐스팅된 상태에서 오버라이딩한 메소드를 호출하면 하위클래스의 메소드가 실행된다!
------------------------------------------------------------------------------------
11. 상속 정리
  1. 상속을 받으면 상위 클래스의 기능을 물려받는다.
  2. 하위 클래스 타입의 객체는 상위 클래스 타입으로 형변환이 가능하다. => 업캐스팅
    -> 업캐스팅 되어 있는 상태일 때 하위 클래스에만 있는 거 부르려면 다운 캐스팅 해줘야 함
  3. 메소드 오버라이딩(재정의) : 상위 클래스에 설계된 메소드를 하위 클래스에서 재정의
    - 업캐스팅 되어있는 상태에서 오버라이딩된 메소드를 호출하면 하위의 메소드가 실행
		  -> 하위에 있는 메소드가 좀 더 구체화 되어 있어서
  4. 메소드 오버로딩(중복정의) : 한 클래스 내에서 메소드의 이름을 동일하게 정의하는 것
    - 매개변수의 타입이나 개수를 다르게! (리턴 타입은 상관 없음)

	5. 추상 메소드, 추상 클래스
	  - 모든 하위 클래스에서 오버라이딩이 일어남 => 상위 클래스에는 구체적인 설계를 할 필요가 없음
	    -> 대신 모든 하위클래스는 해당 메소드를 오버라이딩 해야 함 => 구현의 강제성
    - 추상 클래스는 객체 생성 불가능 => 미완성이니깐
		- 업캐스팅 용도로만 사용 => 규격
		6. 인터페이스
		  - 추상클래스 = 추상메소드 + 일반메소드
		  - but! 상호명만 제공한다? => All추상
		  - 오로지 추상 메소드만 가질 수 있음
      - 상속 키워드 : extends(확장하다)
		  - 구현 키워드 : implements(구현하다)


