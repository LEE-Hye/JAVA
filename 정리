------------------------------이클립스 설치-------------------------------------
1. JDK 1.8 검색(Java Development Kit) -> 첫번째 것 접속(오라클 홈페이지) -> Java SE Development Kit 8u202 -> window x64 다운로드
2. eclipse 검색(Tool) -> 첫번째 것 접속(이클립스 홈페이지) -> Download Package -> 21년 9월 버전 -> Eclipse IDE for Enterprise Java and Web Developers 다운로드
--------------------------------------------------------------------------
JDK(Java Development Kit)  
  - JRE(Java Runtime Environment)
  - JVM(Java virtual Machine) 가상 머신
IDE(Intergrated Development Environment) 작업 공간
  ex) Eclipse, Visual Studio, Android Studio 등
--------------------------------------------------------------------------
1) 환경구축
  - JDK
  - Eclipse
2) 입출력
  - 출력 : System.out.println(출력);
    -> 숫자 + 숫자 = 숫자
    -> 숫자 + 문자 = 문자
  - 입력 : ① 도구 생성(SCanner sc = new Scanner(System.in))
          ② sc.nextInt(), sc.next(); -> 도구 사용
3) 변수 
  : 값을 저장(기억)하는 메모리 공간
  - 숫자 
    -> 정수 - int ex) int a = 10; (정수 타입인 a인 변수에 10을 대입한다)
    -> 실수 - double
  - 문자
    -> char, string(char[])
  - 논리 
    -> ★ boolean(true, false) 
    - 대소문자 구분(아스키코드)
      -> A - 65, B - 66 / a - 97, b - 98
  -> 생성 : 자료형을 붙인다
  -> 사용 : 생성을 하지 않은 변수는 사용할 수 없다.
4) 연산자
  - 결과값이 숫자(산술) : +, -, *, %(나머지), /(몫)
  - 결과값이 논리(논리, 비교) : &&(논리곱), ||(논리합) / ==(같냐?), !=, >=, <=
  - 결과값이 없음(증감, 대입, 삼항) : a++, ++a / a = b(b를 a에 대입) / 조건 ? choice1(출력문 말고 값을 적어줌) : choice2(true면 1, false면 2)
5) 조건문
  - 비교(논리) 연산의 결과에 따라서 명령어를 제어하기 위해 사용(제어 = 조건문 + 반복문)
  if(조건1){ -> 만약에 조건1이 참이면 실행1을 수행!
    실행1;
  }else if(조건2){ -> 그렇지 않고 만약에 조건2라면 실행2를 수행
    실행2   
  }else{  -> 위 조건이 참이 아니라면 실행2를 수행 
    실행3;
  };
  - if문 안에 if문 적는 건 중첩if문

6. 반복문
  - 특정 조건을 만족하는 동안 해당 명령(반복할 명령(범위))을 수행 
    ex) 30만원 수익이 날 때까지 반복 => 횟수 모를 때 while문 적합
    ex) 하루에 10번 주문 받는다 => 횟수 알 때 for문(시작, 끝, 단계를 알 때) 적합
      ex) 1부터 10까지 1씩 증가 / 10부터 100까지 5씩 증가 => 이런 경우는 for문을 써야 함
  for(초기화 구문; 검사조건; 반복후 작업){
    실행할 명령
  };
  -> 초기화 구문 -> 검사조건 -> 실행할 명령 -> 반복후 작업 -> 검사조건 -> 계속 반복
  --------------------------------------------------------------------------------
7. 배열
  : 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것
  - 순서가 없는 데이터에 순서를 부여해주는 것(인덱스를 넣어주는 것)
  1. 반복 사용 가능
  2. 검색 가능
  3. 정렬 가능
생성하면 주소가 생김
[주소=레퍼런스변수] = [메모리=방크기];
데이터타입 [] 변수명 = new 데이터타입 [크기];

8. 메소드(Method)
- 설계는 항상 추상적으로(두루뭉술하게 유연하게) 어떤 데이터가 들어가도 적용할 수 있도록
- 모든 프로그래밍은 끈끈하지않게, 의존적이지 않게 독립적으로 짠다.
- 메소드 : 특정 명령을 모듈화 하는 기법
      ex) 주스를 만든다 라는걸 메소드라 함
- 매개변수(파라미터) : 메소드가 명령을 처리하기 위해 전달받아야하는 데이터 
      ex) 과일 주스 만들기 위한 과일이랑 컵 같은 걸 매개변수라 함
- 리턴값 : 메소드가 해당명령을 수행한 후 반환하는 값(변수, 배열 등)
      ex) 완성된 과일 주스를 받는다
      -> 호출한 곳으로 돌려줌

[메소드 장점]
1. 코드의 중복을 최소화 할 수 있음
2. 모듈화로 인해 가독성이 좋아지고 기능변경 시 빠른 수정이 가능
  -> 유지보수에 용이함
  
[구조 익히기]
public static int add(int a, int b){
  return a+b;
}

- 접근 제한자
    ex) public protected default private
    => public default는 . 찍고 바로 접근 가능
    => private은 get 사용해서 접근
- 메모리 할당 위치
    ex) static
- 리턴 타입
    ex) int(리턴 할거야), void(리턴 안 할거야)
- 메소드 이름
    ex) add
    => 특문은 '_'와 '$'만 가능
- 매개변수
    ex) int a, int b
    => 개수 제한 없음, 필요 없으면 생략 가능
    => 여러개 넣어줄 때 자료형 하나하나 붙여줘야 함
    => 호출할 때 짝 맞춰서 값 
- 리턴 키워드
    ex) return
    => 메소드는 리턴을 만나면 그 즉시 호출한 곳으로 돌아감
- 리턴 값
    ex) a+b
    => 리턴값의 타입은 리턴 타입과 맞춰줘야 한다.
